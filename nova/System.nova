package "nova"

import "nova/io/StreamReader"
import "nova/io/File"
import "nova/io/FileWriter"
import "nova/io/FileReader"
import "nova/time/Time"
import "nova/time/CumulativeTimer"
import "nova/process/Process"
import "nova/NativeSystem.h"

[AutoFinal]
immutable class System {
    external type FILE
    
    external int NULL
    
    external void exit(int code) as externalExit
    external int system(char command[])
    external FILE* getPipe(char command[], exit(Int, String, Bool))
    external bool fgets(char buffer[], int length, FILE* pipe)
    external bool feof(FILE* pipe)
    
    [Target c] visible static final String TARGET = "C"
    [Target js] visible static final String TARGET = "Javascript"
    [Target java] visible static final String TARGET = "Java"
    
    visible static final String OS
    
    visible static final Int WINDOWS = 1
    visible static final Int LINUX = 2
    visible static final Int MAC_OSX = 3
    
    visible static final Int OS_INT
    
    static {
        external c {
            #ifdef _WIN32
                #{OS = "Windows"};
                #{OS_INT = WINDOWS};
            #elif defined(__linux__)
                #{OS = "Linux"};
                #{OS_INT = LINUX};
            #elif defined(__APPLE__)
                #{OS = "Mac OS X"};
                #{OS_INT = MAC_OSX};
            #endif
        }
    }
    
    visible static CumulativeTimer overheadTimer = new CumulativeTimer()
    
    public static exit(Int code) {
        externalExit(code)
    }
    
    public static exit(Int code, String message) {
        exit(code, message, false)
    }
    
    public static exit(Int code, String message, Bool log) {
        if (log) {
            let f = new FileWriter("Log" + Time.currentTimeMillis + ".txt")
            
            if (f.create()) {
                f.writeLine(message)
            }
        }
        
        Console.writeLine(message)
        
        exit(code)
    }
    
    public static execute(String command) -> Process {
        FILE* pipe = getPipe(command.chars.data, exit)
        
        if (pipe == 0) {
            exit(1, "Unable to open pipe")
        }
        
        return new Process(new FileReader(pipe))
    }
    
    public static execute(String[] arguments) =>
        execute(arguments.map(arg => {
            arg.contains(/[ &]/) ? "\"#arg\"" : arg
        }).join(" "))
}