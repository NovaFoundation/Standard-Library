package "nova/time"

import "nova/datastruct/Comparable"
import "nova/datastruct/Tuple2"
import "nova/regex/Regex"

class DateTime implements Comparable<DateTime> {
    /// Milliseconds since January 1 1970
    public Long millis
    
    public Int year, month, dayOfMonth
    
    // public Int => 
    public Int milliseconds => millis % 1000
    
    visible Bool isLeapYear => Calculator.isLeapYear(year)
    
    visible static Long SECS_DAY = 24 * 60 * 60 * 1000
    visible static Int EPOCH_YEAR = 1970
    visible static /*immutable*/ Byte[] MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    visible static Byte[] LEAP_MONTH_DAYS = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    public construct(String input, String format = null) {
        if (format == null) {
            throw new Exception("implicit formats not implemented yet")
        }
        
        Regex.getMatches("yyyy", format).forEach(match => {
            year = Int.parseInt(input.substring(match.start, match.end))
        })
        Regex.getMatches("MM", format).forEach(match => {
            month = Int.parseInt(input.substring(match.start, match.end))
        })
        Regex.getMatches("dd", format).forEach(match => {
            dayOfMonth = Int.parseInt(input.substring(match.start, match.end))
        })
        
        this(year, month, dayOfMonth)
    }
    
    public construct(this Long millis) {
        
        
        // let monthMillisOffset = millis - yearMillisOffset
        // let monthOffset = monthMillisOffset / 30 / 24 / 60 / 60 / 1000
        
        // let secondsMillisOffset = monthMillisOffset - 
        // let secondsMillis = monthMillisOffset / 30
        
        let yearAndDay = Calculator.getYearAndDay(millis)
        year = yearAndDay.first
        dayOfYear = yearAndDay.last
        
        let monthAndDay = Calculator.getMonthAndDay(year, dayOfYear)
        month = monthAndDay.first
        dayOfMonth = monthAndDay.last
    }
    
    public construct(this Int year = 0, this Int month = 1, this Int dayOfMonth = 1) {
        this.year = year
        
        if (month <= 0 || month > 12) {
            throw new InvalidDateException("Invalid month #{month}. Must be 1-12")
        } else if (!Calculator.isValidDayOfMonth(year, month, dayOfMonth)) {
            throw new InvalidDateException("Invalid day of month #dayOfMonth for month #month")
        } else if (month == 2 && dayOfMonth == 29 && !isLeapYear) {
            throw new InvalidDateException("Year #year is not a leap year")
        }
        
        millis += (Long)year * 365 * 24 * 60 * 60 * 1000
        millis += (Long)month * 30 * 24 * 60 * 60 * 1000
        millis += (Long)dayOfMonth * 24 * 60 * 60 * 1000
    }
    
    public compareTo(DateTime other) => (Int)(millis - other.millis)
    
    public toString(String format) -> String {
        let monthString = (month < 10 ? "0" : "") + month
        let dayOfMonthString = (dayOfMonth < 10 ? "0" : "") + dayOfMonth
        
        return "#{year}-#{monthString}-#{dayOfMonthString}"
    }
    
    class InvalidDateException extends Exception {
        public construct(String message) => super(message)
    }
    
    class InvalidDateFormatException extends InvalidDateException {
        public construct(String message) => super(message)
    }
    
    class Calculator {
        public static getLeapYearCount(Int year, Bool inclusive = true) -> Int {
            var Int sum = 0
            
            for (i in 1970..(inclusive ? year + 1 : year)) {
                if (isLeapYear(i)) {
                    sum++
                }
            }
            
            return sum
        }
        
        public static getYear(Long millis) => getYearAndDay(millis).first
        public static getDayOfMonth(Long millis) => getYearAndDay(millis).last
        
        public static getYearSize(Int year) => isLeapYear(year) ? 366 : 365
        public static getMonthDays(Int year) => isLeapYear(year) ? DateTime.LEAP_MONTH_DAYS : DateTime.MONTH_DAYS
        
        public static getYearAndDay(Long millis) -> Int[] {
            var Int year = DateTime.EPOCH_YEAR
            var Int day = millis / DateTime.SECS_DAY
            
            while (day >= (let size = getYearSize(year))) {
                day -= size
                year++
            }
            
            return [year, day + 1]
        }
        
        public static getMonthAndDay(Int year, Int yearDay) -> Int[] {
            var Int month = 0
            var Int monthDay = yearDay - 1
            
            while (monthDay >= getMonthDays(year)[month]) {
                monthDay -= getMonthDays(year)[month++]
            }
            
            return [month + 1, monthDay + 1]
        }
        
        public static isLeapYear(Int year) =>
            (year & 3) == 0 &&
            ((year % 25) != 0 || (year & 15) == 0)
            // year % 4 == 0 &&
            // (year % 400 == 0 || year % 100 != 0)
        
        public static isValidDayOfMonth(Int year, Int month, Int day) => day > 0 && day <= getMonthDays(year)[month - 1]
    }
}