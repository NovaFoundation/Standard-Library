package "nova/meta/library"

import "nova/io/File"
import "nova/meta/library/NativeLibrary.h"

class Library {
    visible File library, loadedLibrary
    
    visible static final String EXTENSION
    
    external type nova_library_handle
    nova_library_handle handle
    
    static {
        if (System.TARGET == "C") {
            match (System.OS_INT) {
                System.WINDOWS => EXTENSION = ".dll"
                System.LINUX => EXTENSION = ".so"
                System.MAC_OSX => EXTENSION = ".dylib"
            }
        } else if (System.TARGET == "Java") {
            EXTENSION = ".jar"
        } else if (System.TARGET == "Javascript") {
            EXTENSION = ".js"
        }
    }
    
    public construct(String location) {
        library = new File(location)
    }
    
    formatFunctionName(String location, Bool static) -> String {
        //nova/test/Test.staticFunc
        //nova_test_Nova_Test_static_Nova_staticFunc
        if ((let dot = location.indexOf('.')) > 0) {
            let packageEnd = location.lastIndexOf('/')
            
            let package = packageEnd > 0 ? location.substring(end: packageEnd).replace("/", "_") + "_Nova_" : ""
            let className = location.substring(packageEnd + 1, dot).replace("/", "_") + "_"
            let name = "Nova_" + location.substring(dot + 1)
            
            return package + className + (static ? "static_" : "") + name
        }
        
        return location
    }
    
    public getFunction(String location, Bool static = true) {//-> func(Int) {
        let name = formatFunctionName(location, static)
        
        external c {
            if (#{handle} != NULL) {
                // typedef void (*staticFunc)(void*, void*);
                //
                // staticFunc func = (staticFunc)nova_get_function(#{handle}, #{location.chars.data});
                // 
                // func(0, 0);
                
                void* func = nova_get_function(#{handle}, #{name.chars.data});
                
                if (func != NULL) {
                    return func;
                } else {
                    // #{return null};
                }
            }
        }
        
        throw new InvalidLibraryException("Cannot call getFunction before loading '#library.location'")
    }
    
    public load() {
        if (loadFile()) {
            external c {
                #{handle} = nova_load_library(#{loadedLibrary.location.chars.data});
                
                if (#{handle} == NULL) {
                    #{throw new InvalidLibraryException("Failed to call LoadLibrary for library at location #loadedLibrary.location")};
                }
            }
        }
    }
    
    loadFile() -> File {
        if (!library.exists) {
            throw new InvalidLibraryException("Library '#library.name' does not exist at location '#library.location'")
        }
        
        var libFile = library
        
        if (libFile.isDirectory) {
            if (libFile = loadFromSource(libFile)) {
                loadedLibrary = libFile
            } else {
                throw new InvalidLibraryException("Failed to load library '#library.location' from source")
            }
        } else {
            loadedLibrary = libFile
        }
        
        if (!loadedLibrary) {
            throw new InvalidLibraryException("Failed to load library '#library.location'")
        }
        
        return loadedLibrary
    }
    
    static loadFromSource(File source) -> File {
        let path = source.location.substring(end: source.location.lastIndexOf('/') + 1)
        let process = System.execute("novac #source.location -library -o #{path}lib#source.rootName")
        
        while (var char = process.reader.readChar()) {
            Console.write(char)
        }
        
        let libFile = new File(path + "lib#source.rootName" + EXTENSION)
        
        if (!libFile.isFile) {
            throw new InvalidLibraryException("Failed to build library '#source.location' from nova source to '#libFile.location'")
        }
        
        return libFile
    }
}