package "nova/datastruct/list"

public interface List<Type> extends Iterable<Type>
{
	visible Int size
	/*[Int index]
	{
		get { return this.get(index) }
		set { this.set(index, value) }
	}
	*/

	visible Iterator<Type> iterator
	{
		get { return null }
		no set
	}

	public Type first
	public Type last

	public toArray() -> Type[]
	{
		Type[] array = new Array()

		for (value in this)
		{
			array.add(value)
		}

		return array
	}

	public contains(Type value) -> Bool
	{
	    return any({ _ == value })
	}

	public forEach(func(Type, Int, List<Type>)) => this
	{
	    Int i = 0

		for (value in this)
		{
			func(value, i++, this)
		}
	}

	public map<Out>(mapFunc(Type, Int, List<Type>) -> Out) -> List<Out>
	{
		Out[] array = new Array(count)

		Int i = 0

		for (element in this)
		{
			array.add(mapFunc(element, i++, this))
		}

		return array
	}

	public any(anyFunc(Type) -> Bool) -> Bool
	{
		for (element in this)
		{
			if (anyFunc(element))
			{
				return true
			}
		}

		return false
	}

	public all(allFunc(Type) -> Bool) -> Bool
	{
		for (element in this)
		{
			if (!allFunc(element))
			{
				return false
			}
		}

		return true
	}

	public filter(filterFunc(Type, Int, List<E>) -> Bool) -> List<Type>
	{
		Type[] list = new Array()

		Int i = 0

		for (value in this)
		{
			if (filterFunc(value, i++, this))
			{
				list.add(value)
			}
		}

		return list
	}

	/*public filter(filterFunc(Type, Int, this<E>) -> Bool) -> this<Type>
	{
		this<Type> list = new this()

		Int i = 0

		for (value in this)
		{
			if (filterFunc(value, i++, this))
			{
				list.add(value)
			}
		}

		return list
	}*/

	public take(Int howMany) -> List<Type>
	{
		Type[] list = new Array()

		Int i = 0

		for (value in this)
		{
			if (i++ >= howMany)
			{
				return list
			}

			list.add(value)
		}

		return list
	}

	public skip(Int howMany) -> List<Type>
	{
		Type[] list = new Array()

		Int i = 0

		for (value in this)
		{
			if (i++ >= howMany)
			{
				list.add(value)
			}
		}

		return list
	}

	public firstWhere(func(Type) -> Bool) -> Type
	{
		for (element in this)
		{
			if (func(element))
			{
				return element
			}
		}

		return null
	}
	
	public firstNonNull<Out>(func(Type) -> Out) -> Out
	{
		for (element in this)
		{
			Out value = func(element)
			
			if (value != null)
			{
				return value
			}
		}

		return null
	}

	public zip<OtherType, Out>(List<OtherType> other, zipper(Type, OtherType) -> Out) -> Out[]
	{
		Iterator<Type> i1 = iterator
		Iterator<OtherType> i2 = other.iterator

		Out[] array = new Array()

		while (i1.hasNext && i2.hasNext)
		{
			array.add(zipper(i1.next, i2.next))
		}

		return array
	}

	//get(Int index) -> Type
	//set(Int index, Type value) -> List<Type>
	//add(Type value) -> List<Type>
	//remove(Type value) -> List<Type>
	//clone() -> List<Type>
	public reverse() -> List<Type>

    public join(String delimiter) -> String
    {
        var str = ""
        var passed = false

        for (element in this)
        {
            if (passed)
            {
                str = str + delimiter
            }
            else
            {
                passed = true
            }

            str = str + element.toString()
        }

        return str
    }
}
