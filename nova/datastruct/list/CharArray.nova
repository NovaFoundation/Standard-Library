package "nova/datastruct/list"

import "nova/primitive/number/Char"

public class CharArray extends Array<Char>
{
	[Override]
	visible CharArrayIterator iterator => new CharArrayIterator(this)
	
	[Override] public Char first => count > 0 ? this[0] : (Char)0
	[Override] public Char last => count > 0 ? this[count - 1] : (Char)0
	
	public Long hashCodeLong => recurse((c, i, a, v) -> 31 * v + (Int)c)
	
	this[Int index] <=> (([PrimitiveArray] Char[])data)[index]
	
	public construct() => super()
	public construct(Int count) => super(count)
	public construct([PrimitiveArray] Char[] data, Int count) => super(data, count)
	
	public sum(func(Char, Int, CharArray, Long) -> Long) -> Long
	{
		Long sum = 0
		Int i = 0
		
		for (value in this)
		{
			sum += func(value, i++, this, sum)
		}
		
		return sum
	}
	
	public recurse(func(Char, Int, CharArray, Long) -> Long) -> Long
	{
		Long value = 0
		Int i = 0
		
		for (element in this)
		{
			value = func(element, i++, this, value)
		}
		
		return value
	}
	
	[Override]
	public map<Out>(mapFunc(Char, Int, CharArray) -> Out) -> Out[]
	{
		Out[] array = new Array()
        
		Int i = 0

		for (element in this)
		{
			array.add(mapFunc(element, i++, this))
		}
		
		return array
	}
	
	[Override]
	public forEach(func(Char, Int, CharArray))
	{
		for (i in 0..count)
		{
			func((Char)get(i), i, this)
		}
	}
	
	[Override]
	public any(anyFunc(Char) -> Bool) -> Bool
	{
		for (element in this)
		{
			if (anyFunc(element))
			{
				return true
			}
		}
		
		return false
	}
	
	[Override]
	public all(allFunc(Char) -> Bool) -> Bool
	{
		for (element in this)
		{
			if (!allFunc(element))
			{
				return false
			}
		}
		
		return true
	}
	
	[Override]
	public filter(filterFunc(Char, Int, CharArray) -> Bool) -> CharArray
	{
		CharArray filtered = new CharArray()
		
		Int i = 0
		
		for (element in this)
		{
			if (filterFunc(element, i++, this))
			{
				filtered.add(element)
			}
		}
		
		return filtered
	}
	
	[Override]
	public take(Int howMany) -> CharArray
	{
		if (howMany > count)
		{
			howMany = count
		}
		
		CharArray list = new CharArray()
		
		for (i in 0..howMany)
		{
			list.add(get(i))
		}
		
		return list
	}
	
	[Override]
	public skip(Int howMany) -> CharArray
	{
		CharArray list = new CharArray()
		
		for (i in howMany..count)
		{
			list.add(get(i))
		}
		
		return list
	}
	
	[Override]
	public firstWhere(func(Char) -> Bool) -> Char
	{
		for (element in this)
		{
			if (func(element))
			{
				return element
			}
		}
		
		return 0
	}
	
	[Override]
    public reverse() -> CharArray
    {
    	var array = new CharArray(count)
    	
    	Int i = 0
    	
    	for (element in this)
    	{
    		array.set(count - ++i, element)
    	}
    	
    	return array
    }
}