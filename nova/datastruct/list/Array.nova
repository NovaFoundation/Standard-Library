package "nova/datastruct/list"

import "nova/primitive/number/Integer"

public class Array<E> implements List<E> {
    external void arrayCopy(E dest[], int dIndex, E src[], int sIndex, int len, int destArrLen, int count)

    visible Int capacity

    visible Int    count
    visible Int position

    [PrimitiveArray]
    visible E[] data

    visible Bool empty => count <= 0

    [Override]
    visible ArrayIterator<E> iterator => new ArrayIterator(this)

    [Override]
    public E first => count > 0 ? this[0] : null

    [Override]
    public E last => count > 0 ? this[count - 1] : null
    
    this[Int index] <=> data[index]
    
    public construct() {
        this(0)

        increaseSize(10)
    }

    public construct(Int count) {
        this.position = 0
        this.capacity = 0

        increaseSize(count)

        this.count = count

        [Target js] data = new E[count]
    }

    public construct([PrimitiveArray] E[] data, Int count) {
        this(count)

        for (i in 0..count) {
            add(data[i])
        }
    }

    public fillRemaining(E value) => this {
        while (count < capacity) {
            add(value)
        }
    }

    public addAll(E[] data) => this {
        for (d in data) {
            add(d)
        }
    }

    public add(E element) => this {
        if (position >= capacity) {
            increaseSize()
        }

        data[position++] = element

        count = Math.max(position, count)
    }

    public add(Int index, E element) => this {
        if (index >= capacity) {
            increaseSize(index + 1)
        }

        add(null)

        shiftRight(index, position)

        data[index] = element

        if (index >= position - 1) {
            position = index + 1
        }
        
        count = Math.max(position, count)
    }

    public remove(Int index) -> E {
        E element = data[index]

        shiftLeft(index + 1, position--)

        return element
    }

    public remove(E element) -> E {
        Int index = indexOf(element)

        if (index >= 0) {
            shiftLeft(index + 1, position--)

            return element
        }

        return null
    }

    public indexOf(E element) -> Int {
        Int i = 0

        for (e in this) {
            if (element == e) {
                return i
            }

            i++
        }

        return -1
    }

    shiftRight(Int left, Int right) => this {
        Int i = right - 1

        while (i > left) {
            data[i] = data[i - 1]

            i--
        }

        data[left] = null
    }

    shiftLeft(Int left, Int right) => this {
        left--
        right--

        for (i in left..right) {
            data[i] = data[i + 1]
        }

        data[right] = null
    }

    public swap(Int index1, Int index2) => this {
        E temp = data[index1]
        data[index1] = data[index2]
        data[index2] = temp
    }

    increaseSize() => this {
        increaseSize(capacity + 3)
    }
    
    [Target not c]
    increaseSize(Int count) => this {
        
    }

    [Target c]
    increaseSize(Int count) => this {
        Int offset = count - capacity
        
        capacity = count
        
        [PrimitiveArray]
        E[] tmp = new E[capacity]
        
        arrayCopy(tmp, 0, data, 0, capacity - offset, capacity, 4)
        
        data = tmp
        
        for (i in (capacity - offset)..capacity) {
            data[i] = null
        }
    }

    [Override]
    public toArray() -> E[] {
        E[] array = new Array(count)
        
        for (i in 0..count) {
            array[i] = data[i]
        }
        
        return array
    }
    
    [Override]
    public map<Out>(mapFunc(E, Int, Array<E>) -> Out) -> Out[] {
        Out[] array = new Array(count)

        Int i = 0

        for (element in this) {
            array.add(mapFunc(element, i++, this))
        }

        return array
    }

    [Override]
    public forEach(func(E, Int, Array<E>)) => this {
        for (i in 0..count) {
            func(data[i], i, this)
        }
    }

    [Override]
    public filter(filterFunc(E, Int, Array<E>) -> Bool) -> E[] {
        E[] filtered = new Array()

        Int i = 0

        for (element in this) {
            if (filterFunc(element, i++, this)) {
                filtered.add(element)
            }
        }

        return filtered
    }

    [Override]
    public take(Int howMany) -> E[] {
        howMany = howMany > count ? count : howMany

        E[] list = new Array()

        for (i in 0..howMany) {
            list.add(data[i])
        }

        return list
    }

    [Override]
    public skip(Int howMany) -> E[] {
        E[] list = new Array()

        for (i in howMany..count) {
            list.add(data[i])
        }

        return list
    }

    [RequireGenericType E extends String]
    public sumSize() -> Long {
        Long sum = 0

        for (value in this) {
            sum = sum + ((String)value).count
        }

        return sum
    }

    /*[RequireGenericType E extends Integer]
    public sum() -> Long {
        Long sum = 0

        for (value in this) {
            sum = sum + (Long)value
        }

        return sum
    }

    [RequireGenericType E extends RealNumber]
    public sum() -> Double {
        Double sum = 0

        for (value in this) {
            sum += value
        }

        return sum
    }*/

    [Override]
    public reverse() -> Array<E> {
        Array<E> array = new Array(count)

        Int i = 0

        for (element in this) {
            array.data[count - ++i] = element
        }

        return array
    }

    public toString() => "Array [#{join(", ")}]"
}
