package "nova/datastruct/list"

import "nova/primitive/number/Integer"

class Array<E> implements List<E> {
    external void arrayCopy(E dest[], int dIndex, E src[], int sIndex, int len, int destArrLen, int count)

    [Visible] Int capacity

    [Visible] Int count <=> count
    [Visible] Int position

    [Visible] [PrimitiveArray] E[] data

    [Visible] Bool empty => count <= 0

    [Override]
    [Visible]
    ArrayIterator<E> iterator => new ArrayIterator(this)

    [Override]
    [Public]
    E first => count > 0 ? this[0] : null

    [Override]
    [Public]
    E last => count > 0 ? this[count - 1] : null
    
    this[Int index] <=> data[index]
    
    [Public]
    construct() {
        this(0)

        increaseSize(10)
    }

    [Public]
    construct(Int count, Int initialCapacity = count) {
        this.position = 0
        this.capacity = 0

        increaseSize(initialCapacity)

        this.count = count

        [Target js] data = new E[count]
    }

    [Public]
    construct([PrimitiveArray] E[] data, Int count) {
        this(count)

        for (i in 0..count) {
            add(data[i])
        }
    }

    [Public]
    fillRemaining(E value) => this {
        while (count < capacity) {
            add(value)
        }
    }

    [Public]
    addAll(E[] data) => this {
        for (d in data) {
            add(d)
        }
    }
    
    [Public]
    addUnique(E element) => this {
        if (!contains(element)) {
            add(element)
        }
    }
    
    [Public] add(E element) => this {
        if (position >= capacity) {
            increaseSize()
        }

        data[position++] = element

        count = Math.max(position, count)
    }

    [Public]
    add(Int index, E element) => this {
        if (index >= capacity) {
            increaseSize(index + 1)
        }

        add(null)

        shiftRight(index, position)

        data[index] = element

        if (index >= position - 1) {
            position = index + 1
        }
        
        count = Math.max(position, count)
    }

    [Public]
    remove(Int index) -> E {
        E element = data[index]

        shiftLeft(index + 1, position--)

        return element
    }

    [Public]
    remove(E element) -> E {
        Int index = indexOf(element)

        if (index >= 0) {
            shiftLeft(index + 1, position--)

            return element
        }

        return null
    }

    [Public]
    indexOf(E element) -> Int {
        Int i = 0

        for (e in this) {
            if (element == e) {
                return i
            }

            i++
        }

        return -1
    }
    
    [Public]
    replace(E element, E other) -> Bool {
        var index = indexOf(element)
        
        if (index >= 0) {
            this[index] = other
            
            return true
        } else {
            return false
        }
    }

    shiftRight(Int left, Int right) => this {
        Int i = right - 1

        while (i > left) {
            data[i] = data[i - 1]

            i--
        }

        data[left] = null
    }

    shiftLeft(Int left, Int right) => this {
        left--
        right--

        for (i in left..right) {
            data[i] = data[i + 1]
        }

        data[right] = null
    }

    [Public]
    swap(Int index1, Int index2) => this {
        E temp = data[index1]
        data[index1] = data[index2]
        data[index2] = temp
    }

    increaseSize() => this {
        increaseSize(capacity + 3)
    }
    
    [Target not c]
    increaseSize(Int count) => this {
        
    }

    [Target c]
    increaseSize(Int count) => this {
        Int offset = count - capacity
        
        capacity = count
        
        [PrimitiveArray]
        E[] tmp = new E[capacity]
        
        arrayCopy(tmp, 0, data, 0, capacity - offset, capacity, 4)
        
        data = tmp
        
        for (i in (capacity - offset)..capacity) {
            data[i] = null
        }
    }
    
    [Public] [Override]
    toArray() => map({ _ })
    
    [Public] [Override]
    map<Out>(mapFunc(E, Int, Array<E>) -> Out) -> Out[] {
        Out[] array = new Array(count)

        Int i = 0

        for (element in this) {
            array.add(mapFunc(element, i++, this))
        }

        return array
    }
    
    [Public] [Override]
    forEach(func(E, Int, Array<E>)) => this {
        for (i in 0..count) {
            func(data[i], i, this)
        }
    }

    [Public] [Override]
    filter(filterFunc(E, Int, Array<E>) -> Bool) -> E[] {
        E[] filtered = new Array()

        Int i = 0

        for (element in this) {
            if (filterFunc(element, i++, this)) {
                filtered.add(element)
            }
        }

        return filtered
    }
    
    [Public] [Override]
    take(Int howMany) -> E[] {
        howMany = howMany > count ? count : howMany

        E[] list = new Array()

        for (i in 0..howMany) {
            list.add(data[i])
        }

        return list
    }
    
    [Public] [Override]
    skip(Int howMany) -> E[] {
        E[] list = new Array()

        for (i in howMany..count) {
            list.add(data[i])
        }

        return list
    }

    [RequireGenericType E extends String]
    [Public]
    sumSize() -> Long {
        Long sum = 0

        for (value in this) {
            sum += ((String)value).count
        }

        return sum
    }
    
    /*[RequireGenericType E extends Integer]
    [Public] sum() -> Long {
        Long sum = 0

        for (value in this) {
            sum = sum + (Long)value
        }

        return sum
    }
    
    [RequireGenericType E extends RealNumber]
    [Public] sum() -> Double {
        Double sum = 0

        for (value in this) {
            sum += value
        }

        return sum
    }*/
    
    [Public] [Override]
    reverse() -> E[] {
        E[] array = new Array(count)

        Int i = 0

        for (element in this) {
            array.data[count - ++i] = element
        }

        return array
    }
    
    [Public]
    toString() => "Array [#{join(", ")}]"
}
