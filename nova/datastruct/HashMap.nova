package "nova/datastruct"

import "nova/datastruct/list/List"
import "nova/operators/EqualsOperator"

[AutoFinal]
[Immutable "ImmutableHashMap"]
class HashMap<K extends EqualsOperator, V> implements List<Pair<K, V>> {
    Pair<K, V>[][] buckets
    
    visible var Int count
    
    this[K key] -> V {
        get {
            return key ? getPair(key)?.value : null
        }
        
        set {
            if (!key) return null
            
            remove(key)
            
            getBucket(key).add(new Pair<K, V>(key, value))
            
            count++
        }
    }
    
    public construct(Int bucketCount = 5, private Int bucketSize = 5) {
        buckets = new Pair<K, V>[bucketCount][bucketSize]
    }
    
    public construct(HashMap<K, V> source, Int bucketCount = 5, private Int bucketSize = 5) {
        this(bucketCount, bucketSize)
        
        source.forEach(pair => {
            add(pair.key, pair.value)
        })
    }
    
    public add(K key, V value) => this[key] = value
    
    [Override]
    public toArray() => map({ _ })
    
    // [Override]
    // public contains(Pair<K, V> value) =>
    //     (let pair = getPair(value.key)) &&
    //     pair.value == value.value
    
    [Override]
    public contains(Pair<K, V> value) -> Bool {
        if (!value.key) return false
        
        let pair = getPair(value.key)
        
        return pair && pair.value == value.value
    }
    
    [Override]
    public any(func(Pair<K, V>) -> Bool) => false {
        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair && func(pair)) {
                    return true
                }
            }
        }
    }
    
    [Override]
    public all(func(Pair<K, V>) -> Bool) => true {
        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair && !func(pair)) {
                    return false
                }
            }
        }
    }
    
    [Override]
    public map<Out>(func(Pair<K, V>, Int, HashMap<K, V>) -> Out) -> Out[] {
        let array = new Out[]
        
        var Int i = 0
        
        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair) {
                    array.add(func(pair, i++, this))
                }
            }
        }

        return array
    }
    
    [Override]
    public filter(func(Pair<K, V>, Int, HashMap<K, V>) -> Bool) -> Pair<K, V>[] {
        let array = new Pair<K, V>[]
        
        var Int i = 0
        
        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair && func(pair, i++, this)) {
                    array.add(pair)
                }
            }
        }

        return array
    }
    
    [Override]
    public join(String delimiter) -> String {
        var Int i = 0
        
        var output = ""
        
        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair) {
                    if (i > 0) {
                        output = output + delimiter
                    }
                    
                    output = output + pair
                }
            }
        }

        return output
    }
    
    [Override] public skip(Int num) => map({ _ }).skip(num)
    [Override] public take(Int num) => map({ _ }).take(num)
    [Override] public reverse() => map({ _ }).reverse()
    
    [Override]
    public firstWhere(func(Pair<K, V>) -> Bool) -> Pair<K, V> => null//=>
    //buckets.firstNonNull({ _.firstWhere(pair -> pair && func(pair)) })
    {
        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair && func(pair)) {
                    return pair
                }
            }
        }
    }
    
    [Override]
    public forEach(func(Pair<K, V>, Int, HashMap<K, V>)) => this {
        var Int i = 0
        
        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair) {
                    func(pair, i++, this)
                }
            }
        }
    }
    
    getBucket(K key) => buckets[(Int)(key.hashCodeLong & (buckets.count - 1))]
    getPair(K key) => getBucket(key).filter(x => x && x.key.equals(key)).first
    
    public remove(K key) -> V => null {
        if (!key) return null
        
        let bucket = getBucket(key)
        
        var Int i = 0
        
        for (pair in bucket) {
            if (pair && ((EqualsOperator)pair.key).equals(key)) {
                bucket.remove(i)
                count--
                
                return pair.value
            }
            
            i++
        }
    }
    
    public containsKey(K key) => key && getPair(key)
    
    public clone() => new HashMap<K, V>(this)
    
    public toImmutable() => new ImmutableHashMap<K, V>(this)
}