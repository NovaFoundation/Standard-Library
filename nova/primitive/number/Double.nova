package "nova/primitive/number"

import "nova/datastruct/Comparable"
import "nova/operators/EqualsOperator"
import "nova/operators/MultiplyOperator"
import "nova/operators/MultiplyEqualsOperator"

class Double extends Number implements RealNumber {
    external void sprintf(char buffer[], char format[], double value)
    external char[] realloc(char buffer[], int size)
    external int strlen(char buffer[])
    external double strtod(char str[], char* pEnd[])
    
    public Double realValue => value
    public Long integerValue => (Long)value
    
    public construct(public Double value) {}
    
    public static numDigits(Double number) -> Int {
        Int size = number < 0 ? 2 : 1
        
        number /= 10
        
        while (number > 0) {
            number /= 10
            
            size++
        }
        
        return size
    }
    
    static genString(native Char buffer[], Int lastIndex) -> String {
        buffer = realloc(buffer, ++lastIndex + 1)
        
        buffer[lastIndex] = '\0'
        
        return new String(buffer)
    }
    
    static native genBuffer(Double value) -> Char[] {
        Int  size     = 11 + 1 + 15
        
        native Char[] buffer = new Char[size]
        
        sprintf(buffer, "%.15f", value)
        
        return buffer
    }
    
    static repetition(native Char[] buffer, Int start) -> Int {
        Int  index = start
        Char c     = buffer[index]
        
        while (buffer[--index] == c);
        
        return start - index - 1
    }
    
    static lastSignificantDigit(native Char[] buffer, Int start) -> Int {
        while (buffer[start--] == '0');
        
        return start + 1
    }
    
    public native static toCharArray(Double value) -> Char[] {
        external js {
            return #{value}.toString();
        }
    }
    
    [Target js]
    public static toString(Double value) => new String(toCharArray(value))
    
    [Target not js]
    public static toString(Double value) -> String {
        native Char buffer[]  = genBuffer(value)
        Int  size      = strlen(buffer)
        Int  lastIndex = size - 1
        
        Char c = buffer[--lastIndex]
        
        if (c == '0' || c == '9') {
            while (buffer[lastIndex--] == c);
            
            if (buffer[++lastIndex] == '.') {
                lastIndex++
                
                return genString(buffer, lastIndex)
            } else {
                if (lastIndex >= size - 3 - 4) {
                    lastIndex = size - 1
                } else if (c == '9') {
                    buffer[lastIndex]++
                    
                    return genString(buffer, lastIndex)
                }
            }
        } else {
            Int rep = repetition(buffer, lastIndex)
            
            if (rep > 5) {
                buffer[lastIndex] = c
                
                if (c >= '5') {
                    c++;
                }
                
                buffer[++lastIndex] = c
                
                return genString(buffer, lastIndex)
            }
        }
        
        lastIndex = lastSignificantDigit(buffer, size - 1)
        
        return genString(buffer, lastIndex)
    }
    
    public static parseDouble(String str) -> Double {
        native Char[] pEnd
        
        return strtod(str.chars.data, pEnd)
    }
    
    public compareTo(Number other) => other.compareToReal(value)
    public compareToReal(Double other) => this.value - other
    public compareToInteger(Long other) => this.value - other
    
    public plus(Number other) => other.plusReal(value)
    public plusReal(Double other) => this.value + other
    public plusInteger(Long other) => this.value + other
    
    public plusEquals(Number other) => other.plusEqualsReal(value)
    public plusEqualsReal(Double other) => this.value += other
    public plusEqualsInteger(Long other) => this.value += other
    
    public minus(Number other) => other.minusReal(value)
    public minusReal(Double other) => this.value - other
    public minusInteger(Long other) => this.value - other
    
    public minusEquals(Number other) => other.minusEqualsReal(value)
    public minusEqualsReal(Double other) => this.value -= other
    public minusEqualsInteger(Long other) => this.value -= other
    
    public multiply(Number other) => other.multiplyReal(value)
    public multiplyReal(Double other) => this.value * other
    public multiplyInteger(Long other) => this.value * other
    
    public multiplyEquals(Double other) => other.multiplyEqualsReal(value)
    public multiplyEqualsReal(Double other) => this.value *= other
    public multiplyEqualsInteger(Long other) => this.value *= other
    
    public equals(Number other) => other.equalsReal(value)
    public equalsReal(Double other) => this.value == other
    public equalsInteger(Long other) => this.value == other
    
    public toString() => toString(value)
}