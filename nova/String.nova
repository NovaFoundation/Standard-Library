package "nova"

import "nova/datastruct/Comparable"
import "nova/datastruct/HashSet"
import "nova/datastruct/list/StringCharArray"
import "nova/regex/Regex"
import "nova/regex/Match"
import "nova/regex/Pattern"

class String implements Comparable<String> {
    visible Int count

    visible StringCharArray chars
    
    this[Int index] <=> chars[index]

    static Char[] WHITESPACE = [ ' ', '\t', '\n', '\r' ]
    
    external void strcpy(char dst[], char src[])
    external void strcat(char dst[], char src[])
    external int strlen(char chars[])
    external void memcpy(char dst[], char* src[], int count)

    private static HashSet<String> pool = new HashSet(121, 1)

    public Long hashCodeLong => chars.hashCodeLong
    
    [Target not js]
    public construct(Char c) {
        [PrimitiveArray]
        Char[] chars = new Char[2]

        chars[0] = c
        chars[1] = '\0'

        this(chars)
    }
    
    [Target js]
    public construct(Char c) {
        [PrimitiveArray]
        Char[] chars
        
        external {
            chars = [#{c}];
        }

        this(chars)
    }
    
    [Target not js]
    public construct([PrimitiveArray] Char[] chars) {
        count = calculateSize(chars)

        this.chars = new StringCharArray(chars, count)
        
        if (chars[count] != '\0') {
            chars[count] = '\0'
        }

        /*if (pool.contains(this)) {
            Console.writeLine("Duplicate string #this created")
        } else {
            //pool.add(this)
        }*/
    }
    
    [Target js]
    public construct([PrimitiveArray] Char[] chars) {
        count = calculateSize(chars)

        this.chars = new StringCharArray(chars, count)
    }

    public construct(Char[] chars) {
        count = chars.count

        this.chars = new StringCharArray(chars)
    }

    calculateSize([PrimitiveArray] Char[] chars) -> Int {
        [Target c] return strlen(chars)
        
        external js {
            return #{chars}.length;
        }
        external java {
            return #{chars}.length;
        }
    }

    [Target not js]
    public concat(String str) -> String {
        Int sz = str.count + count + 1

        [PrimitiveArray]
        Char[] newData = new Char[sz]

        strcpy(newData, chars.data)
        strcat(newData, str.chars.data)

        newData[sz - 1] = '\0'

        return new String(newData)
    }
    
    [Target js]
    public concat(String str) -> String {
        external {
            var newData = #{chars.data}.slice(0, #{count}).concat(#{str.chars.data});
            
            return new novaConstructors.newString1(newData);
        }
    }
    
    public equals(String other) => compareTo(other) == 0
    
    public replace(Pattern pattern, String replace) -> String {
    	String output = this
    	
        Int offset = 0
        
        Regex.getMatches(pattern.pattern, this).forEach(match -> {
        	output = output.substring(0, match.start + offset) + replace + output.substring(match.end + offset)
        	offset += replace.count - match.count
        })
        
        return output
    }
    
    public replace(String search, String replace) -> String {
        String output = this

        Int index = 0

        while ((index = output.indexOf(search)) >= 0) {
            output = output.substring(0, index) + replace + output.substring(index + search.count)
        }

        return output
    }
    
    public startsWith(String search) => indexOf(search) == 0
    public startsWith(Pattern search) => indexOf(search) == 0
    public contains(String search) => indexOf(search) >= 0
    public contains(Pattern search) => indexOf(search) >= 0
    public endsWith(String search) => count > 0 && indexOf(search) == count - search.count - 1
    public endsWith(Pattern search) => count > 0 && indexOf(search) == count - search.pattern.count - 1
    public matches(Pattern pattern) -> Bool {
    	var matches = Regex.getMatches(pattern, this)
    	
    	return matches.count == 1 && matches[0].start == 0 && matches[0].end == count
    }

    public indexOf(Pattern search, Int start = 0, Int direction = 1, Int defaultReturnValue = -1) -> Int {
    	var first = Regex.getMatches(search, this).first
    	
    	if (first != null) {
    		return first.start
    	}
    	
    	return defaultReturnValue
    }
    
    public indexOf(Char search, Int start = 0, Int direction = 1, Int defaultReturnValue = -1) =>
    	indexOf("#search", start, direction, defaultReturnValue)
    public indexOf(String search, Int start = 0, Int direction = 1, Int defaultReturnValue = -1) -> Int {
        Int i = start

        while (i < count && i >= 0) {
            Bool found = true

            Int j = 0

            while (j < search.count && i + j < count && found) {
                if (search.chars[j] != chars[i + j]) {
                    found = false
                }

                j++
            }

            if (found) {
                return i
            }

            i += direction
        }

        return defaultReturnValue
    }

    public lastIndexOf(String search, Int start = count - 1, Int defaultReturnValue = -1) =>
        indexOf(search, start, -1, defaultReturnValue: defaultReturnValue)

    public substring(Int start = 0, Int end = count) -> String {
        if (end - start <= 0) {
            if (end - start < 0) {
                throw new Exception("Substring bounds of [#start, #end] are invalid")
            }
            
            return ""
        } else if (start == 0 && end == count) {
            return this
        }
        
        [PrimitiveArray]
        Char buf[] = new Char[end - start + 1]
        
        [PrimitiveArray]
        Char[] arr = chars.data
        
        external c {
            memcpy(#{buf}, &#{arr[start]}, #{end - start});
            
            #{buf[end - start] = '\0'};
        }
        
        external js {
            #{buf} = #{arr}.slice(#{start}, #{end});
        }
        
        return new String(buf)
    }

    public trim(Int start = 0, Int end = count - 1) -> String {
        while (start <= end && WHITESPACE.contains(chars[start])) start++
        while (end >= start && WHITESPACE.contains(chars[end])) end--
        
        return start > end ? "" : substring(start, end + 1)
    }
    
    public lastChar() => count > 0 ? chars[count - 1] : (Char)0
    public toLowerCase() => transform(Char.toLowerCase)
    public toUpperCase() => transform(Char.toUpperCase)
    public capitalize() => count > 0 ? chars[0].toUpperCase() + substring(1) : this

    public transform(transform(Char, Int) -> Char) -> String {
        [PrimitiveArray]
        Char[] newData = new Char[count]

        for (i in 0..count) {
            newData[i] = transform(chars[i], i)
        }

        return new String(newData)
    }

    public getStringBetween(String before, String after, Int start = 0) -> String {
        Int s = indexOf(before, start)
        Int e = indexOf(after, s + 1)

        if (s >= 0 && e > 0) {
            return substring(s + before.count, e)
        }

        return ""
    }

    public surroundWith(String str, Bool symmetrical = false) =>
        "#{str}#{this}#{symmetrical ? new String(str.chars.reverse()) : str}"

    public compareTo(String other) -> Int {
        var min = Math.min(count, other.count)

        for (i in 0..min) {
            if (chars[i] - other.chars[i] != 0) {
                return chars[i] - other.chars[i]
            }
        }

        return count - other.count
    }
    
    public split(Pattern regex) -> String[] {
    	String[] strs = new Array()
    	
    	Int start = 0
    	
    	Regex.getMatches(regex.pattern, this).forEach(match -> {
    		strs.add(substring(start, match.start))
    		
    		start = match.end
    	})
    	
    	strs.add(substring(start))
    	
    	return strs
    }

    public toString() => this
}